3D:


printed = 0
model wire
gosub"drawContext"

dim aa[3]
dim vertexList[6][3]

dim vertexWIP[6][3]
dim vertexTemp[6][3]

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
dim nPlane[3]
dim pPlane[3]
dim startP[3]
dim endP[3]

for bb = 1 TO 6
	vertexWIP[bb][1] = 0
	vertexWIP[bb][2] = 0
	vertexWIP[bb][3] = 0
	vertexList[bb][1] = 0
	vertexList[bb][2] = 0
	vertexList[bb][3] = 0
	vertexTemp[bb][1] = 0
	vertexTemp[bb][2] = 0
	vertexTemp[bb][3] = 0
next bb

for v = 1 to 3
	vertexWIP[v][1] = polyP[v][1]
	vertexWIP[v][2] = polyP[v][2]
	vertexWIP[v][3] = polyP[v][3]
next v




if clipNear then
	!Clipping to Near Plane
	nPlane[1] = 0:	nPlane[2] = 0:	nPlane[3] = 1
	pPlane[1] = 0:	pPlane[2] = 0:	pPlane[3] = zNear
	gosub "clipPoly"
endif
if clipFar then
	!Clipping to Far Plane
	nPlane[1] = 0:	nPlane[2] = 0:	nPlane[3] = -1
	pPlane[1] = 0:	pPlane[2] = 0:	pPlane[3] = zFar
	gosub "clipPoly"
endif
if clipLeft then
	!Clipping to Left Plane
	nPlane[1] = cos(fovH):	nPlane[2] = 0:	nPlane[3] = sin(fovH)
	pPlane[1] = 0:	pPlane[2] = 0:	pPlane[3] = 0.000001
	gosub "clipPoly"
endif
if clipRight then
	!Clipping to Right Plane
	nPlane[1] = -cos(fovH):	nPlane[2] = 0:	nPlane[3] = sin(fovH)
	pPlane[1] = 0:	pPlane[2] = 0:	pPlane[3] = 0.000001
	gosub "clipPoly"
endif
if clipTop then
	!Clipping to Top Plane
	nPlane[1] = 0:	nPlane[2] = -cos(fovV):	nPlane[3] = sin(fovV)
	pPlane[1] = 0:	pPlane[2] = 0:	pPlane[3] = 0.000001
	gosub "clipPoly"
endif
if clipBottom then
	!Clipping to Bottom Plane
	nPlane[1] = 0:	nPlane[2] = cos(fovV):	nPlane[3] = sin(fovV)
	pPlane[1] = 0:	pPlane[2] = 0:	pPlane[3] = 0.000001
	gosub "clipPoly"
endif

!gosub "drawBalls"


end








"dotProduct":

dP = aa[1] * nPlane[1] + aa[2] * nPlane[2] + aa[3] * nPlane[3]

return


"clipPoly":


nVert = 0
for p = 1 to 6
	if abs(vertexWIP[p][1]) > esp or abs(vertexWIP[p][2]) > esp or abs(vertexWIP[p][3]) > esp then
		nVert = nVert + 1
	endif
next p
nResult = 0
nVertex = 0
for pp = 1 to nVert
	if pp < nVert then
		for i = 1 to 3
			startP[i] 	= vertexWIP[pp][i]
			endP[i] 	= polyP[pp + 1][i]
		next i
	else
		for i = 1 to 3
			startP[i] 	= vertexWIP[pp][i]
			endP[i] 	= polyP[1][i]
		next i
	endif
	gosub "clipEdge"
next pp
for p = 1 to nResult
	vertexWIP[p][1] = vertexTemp[p][1]: vertexTemp[p][1] = 0
	vertexWIP[p][2] = vertexTemp[p][2]: vertexTemp[p][2] = 0
	vertexWIP[p][3] = vertexTemp[p][3]: vertexTemp[p][3] = 0
next p
!if nResult < 6 then
!	for d = nResult + 1 to (6 - nResult)
!	vertexWIP[d][1] = 0: vertexTemp[d][1] = 0
!	vertexWIP[d][2] = 0: vertexTemp[d][2] = 0
!	vertexWIP[d][3] = 0: vertexTemp[d][3] = 0
!	next d
!endif

print printed, "###################################################"
for u = 1 to 6
	print vertexWIP[u][1], vertexWIP[u][2], vertexWIP[u][3]
next u
	print ""
printed = printed + 1

gosub "drawBalls"
!gosub "drawPoly"


return






















"clipEdge":

!nVertex = 1

aa[1] = startP[1] - pPlane[1]
aa[2] = startP[2] - pPlane[2]
aa[3] = startP[3] - pPlane[3]
gosub "dotProduct"
dPstart = dP

aa[1] = endP[1] - pPlane[1]
aa[2] = endP[2] - pPlane[2]
aa[3] = endP[3] - pPlane[3]
gosub "dotProduct"
dPend = dP

if sgn(dPstart) <> sgn(dPend) then
	aa[1] = endP[1] - startP[1]
	aa[2] = endP[2] - startP[2]
	aa[3] = endP[3] - startP[3]
	gosub "dotProduct"
	distN = dP
	if sgn(dPstart) = -1 then
		t = (distN - dPend) / distN
		nVertex = nVertex + 1
		vertexTemp[nVertex][1] = startP[1] + t * (endP[1] - startP[1])
		vertexTemp[nVertex][2] = startP[2] + t * (endP[2] - startP[2])
		vertexTemp[nVertex][3] = startP[3] + t * (endP[3] - startP[3])
		nResult = nResult + 1
	endif	
	if sgn(dPend) = -1 then
		t = (-distN - dPstart) / distN
		nVertex = nVertex + 1
		vertexTemp[nVertex][1] = endP[1] - t * (startP[1] - endP[1])
		vertexTemp[nVertex][2] = endP[2] - t * (startP[2] - endP[2])
		vertexTemp[nVertex][3] = endP[3] - t * (startP[3] - endP[3])
		nResult = nResult + 1
	else
		nVertex = nVertex + 1
		vertexTemp[nVertex][1] = endP[1]
		vertexTemp[nVertex][2] = endP[2]
		vertexTemp[nVertex][3] = endP[3]
		nResult = nResult + 1
	endif
else
	if sgn(dPstart) > 0 and sgn(dPend) > 0 then
		nVertex = nVertex + 1
		vertexTemp[nVertex][1] = endP[1]
		vertexTemp[nVertex][2] = endP[2]
		vertexTemp[nVertex][3] = endP[3]	
		nResult = nResult + 1
	endif
endif

return

"drawBalls":

for i = 1 to nVertex - 1
	if abs(vertexWIP[i][1]) > 0.1 and abs(vertexWIP[i][2]) > 0.1 and abs(vertexWIP[i][3]) > 0.1 then
		add vertexWIP[i][1], vertexWIP[i][2], vertexWIP[i][3]
		sphere diaB/2
		del 1
		!put vertexWIP[i][1], vertexWIP[i][2], vertexWIP[i][3]
	endif
next i

return
























"drawPoly":

material matPoly
model solid
plane nsp/3, get(nsp)
model wire

return

"drawContext":

hotspot polyP[1][1], polyP[1][2], 0, unID, polyP[1][3], 1 + 128			:unID = unID + 1
hotspot polyP[1][1], polyP[1][2], polyP[1][3], unID, polyP[1][3], 2		:unID = unID + 1
hotspot polyP[1][1], polyP[1][2], -1, unID, polyP[1][3], 3				:unID = unID + 1
hotspot polyP[2][1], polyP[2][2], 0, unID, polyP[2][3], 1 + 128			:unID = unID + 1
hotspot polyP[2][1], polyP[2][2], polyP[2][3], unID, polyP[2][3], 2		:unID = unID + 1
hotspot polyP[2][1], polyP[2][2], -1, unID, polyP[2][3], 3				:unID = unID + 1
hotspot polyP[3][1], polyP[3][2], 0, unID, polyP[3][3], 1 + 128			:unID = unID + 1
hotspot polyP[3][1], polyP[3][2], polyP[3][3], unID, polyP[3][3], 2		:unID = unID + 1
hotspot polyP[3][1], polyP[3][2], -1, unID, polyP[3][3], 3				:unID = unID + 1


define style "text_style" "Arial", 1000, 5, 0
set style "text_style"
add polyP[1][1], polyP[1][2], polyP[1][3]
	rotx 90
	text 0.01, 0, "A"
	del 1
del 1
add polyP[2][1], polyP[2][2], polyP[2][3]
	rotx 90
	text 0.01, 0, "B"
	del 1
del 1
add polyP[3][1], polyP[3][2], polyP[3][3]
	rotx 90
	text 0.01, 0, "C"
	del 1
del 1

pen penX
lin_ 0, 0, 0, lgAxis, 0, 0
pen penY
lin_ 0, 0, 0, 0, lgAxis, 0
pen penZ
lin_ 0, 0, 0, 0, 0, lgAxis
material matFrustum
!Near Plane
plane 4,
-zNear, -zNear / aspectRatio, zNear,
 zNear, -zNear / aspectRatio, zNear,
 zNear,  zNear / aspectRatio, zNear,
-zNear,  zNear / aspectRatio, zNear
!Far Plane
plane 4,
-zFar, -zFar / aspectRatio, zFar,
 zFar, -zFar / aspectRatio, zFar,
 zFar,  zFar / aspectRatio, zFar,
-zFar,  zFar / aspectRatio, zFar
!Bottom Plane
plane 4,
-zNear, -zNear / aspectRatio, zNear,
 zNear, -zNear / aspectRatio, zNear,
  zFar,  -zFar / aspectRatio, zFar,
 -zFar,  -zFar / aspectRatio, zFar
!Top Plane
plane 4,
 zNear,  zNear / aspectRatio, zNear,
-zNear,  zNear / aspectRatio, zNear,
 -zFar,   zFar / aspectRatio, zFar,
  zFar,   zFar / aspectRatio, zFar
!Left Plane
plane 4,
-zNear,  zNear / aspectRatio, zNear,
 -zFar,   zFar / aspectRatio, zFar,
 -zFar,  -zFar / aspectRatio, zFar,
-zNear, -zNear / aspectRatio, zNear
!Right Plane
plane 4,
 zNear,  zNear / aspectRatio, zNear,
  zFar,   zFar / aspectRatio, zFar,
  zFar,  -zFar / aspectRatio, zFar,
 zNear, -zNear / aspectRatio, zNear
material matTriangle


!Triangle to clip
plane 3,
polyP[1][1], polyP[1][2], polyP[1][3],
polyP[2][1], polyP[2][2], polyP[2][3],
polyP[3][1], polyP[3][2], polyP[3][3]

return

















2D:


project2 3, 270, 2
hotspot2 0, 0

HOTSPOT2 0, polyP[1][2], unID, polyP[1][1], 1+128			:unID = unID+1
HOTSPOT2 polyP[1][1], polyP[1][2], unID, polyP[1][1], 2		:unID = unID+1
HOTSPOT2 -1, polyP[1][2], unID, polyP[1][1], 3				:unID = unID+1
HOTSPOT2 polyP[1][1], 0, unID, polyP[1][2], 1+128			:unID = unID+1
HOTSPOT2 polyP[1][1], polyP[1][2], unID, polyP[1][2], 2		:unID = unID+1
HOTSPOT2 polyP[1][1], -1, unID, polyP[1][2], 3				:unID = unID+1

HOTSPOT2 0, polyP[2][2], unID, polyP[2][1], 1+128			:unID = unID+1
HOTSPOT2 polyP[2][1], polyP[2][2], unID, polyP[2][1], 2		:unID = unID+1
HOTSPOT2 -1, polyP[2][2], unID, polyP[2][1], 3				:unID = unID+1
HOTSPOT2 polyP[2][1], 0, unID, polyP[2][2], 1+128			:unID = unID+1
HOTSPOT2 polyP[2][1], polyP[2][2], unID, polyP[2][2], 2		:unID = unID+1
HOTSPOT2 polyP[2][1], -1, unID, polyP[2][2], 3				:unID = unID+1

HOTSPOT2 0, polyP[3][2], unID, polyP[3][1], 1+128			:unID = unID+1
HOTSPOT2 polyP[3][1], polyP[3][2], unID, polyP[3][1], 2		:unID = unID+1
HOTSPOT2 -1, polyP[3][2], unID, polyP[3][1], 3				:unID = unID+1
HOTSPOT2 polyP[3][1], 0, unID, polyP[3][2], 1+128			:unID = unID+1
HOTSPOT2 polyP[3][1], polyP[3][2], unID, polyP[3][2], 2		:unID = unID+1
HOTSPOT2 polyP[3][1], -1, unID, polyP[3][2], 3				:unID = unID+1













MASTER:


unID = 1
esp = 0.000001

fovV = atn(tan(fovH) / aspectRatio)